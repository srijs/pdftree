#include <node.h>
#include <node_buffer.h>
#include <poppler.h>
#include <stdlib.h>
#include <cairo.h>
#include <cairo-svg.h>
#include <string.h> 
#include <sstream>
#include <algorithm>
#include "page.h"
#include "page_job.h"
#include "document.h"
#include "formats.h"
#include "link.h"

using namespace v8;
using namespace node;
using namespace std;


Persistent<Function> Page::constructor;

void Page::Init(Handle<Object> target) {
	unsigned int i;
	Local<FunctionTemplate> tpl = FunctionTemplate::New();
	tpl->SetClassName(String::NewSymbol("PDFPage"));
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Local< ObjectTemplate > prt = tpl->PrototypeTemplate();
	
	for(i = 0; formatName(i) != NULL; i++) {
		Local<Function> fnc = FunctionTemplate::New(ConvertTo)->GetFunction();
		Local<String> sym = String::NewSymbol(formatName(i));
		fnc->SetName(sym);
		prt->Set(sym, fnc);
	}

	prt->SetAccessor(String::NewSymbol("links"), Page::GetLinks, 0 /* setter */, Handle<Value>(), 
			static_cast<v8::AccessControl>(DEFAULT), 
			static_cast<v8::PropertyAttribute>(ReadOnly | DontEnum)
			);

	prt->SetAccessor(String::NewSymbol("text"), Page::GetText, 0 /* setter */, Handle<Value>(), 
			static_cast<v8::AccessControl>(DEFAULT),
			static_cast<v8::PropertyAttribute>(ReadOnly | DontEnum)
			);

	prt->SetAccessor(String::NewSymbol("textLayout"), Page::GetTextLayout, 0 /* setter */, Handle<Value>(), 
			static_cast<v8::AccessControl>(DEFAULT),
			static_cast<v8::PropertyAttribute>(ReadOnly | DontEnum)
			);

	prt->SetAccessor(String::NewSymbol("textChunks"), Page::GetTextChunks, 0 /* setter */, Handle<Value>(), 
			static_cast<v8::AccessControl>(DEFAULT),
			static_cast<v8::PropertyAttribute>(ReadOnly | DontEnum)
			);

	prt->SetAccessor(String::NewSymbol("textAttributes"), Page::GetTextAttributes, 0 /* setter */, Handle<Value>(), 
			static_cast<v8::AccessControl>(DEFAULT),
			static_cast<v8::PropertyAttribute>(ReadOnly | DontEnum)
			);

	constructor = Persistent<Function>::New(tpl->GetFunction());
	target->Set(String::NewSymbol("Page"), constructor);
}

Page::Page(Document *document, int index) {
	this->document = document;
	this->index = index;
	this->pg = poppler_document_get_page(this->document->doc, this->index);
	poppler_page_get_size (this->pg, &this->w, &this->h);
	this->label = poppler_page_get_label(this->pg);
}

Page::~Page() {
	g_free(this->label);
	if(!this->handle_.IsEmpty())
		this->handle_.Dispose();
	g_object_unref(this->pg);
};

void Page::createObject() {
	HandleScope scope;

	if(!this->handle_.IsEmpty())
		return;
	Handle<Value> argv[] = {
		//this->document->handle_
	};
	Local<Object> instance = (*constructor)->NewInstance(LENGTH(argv), argv);
	instance->Set(String::NewSymbol("width"), Local<Number>::New(Number::New(this->w)), 
			static_cast<v8::PropertyAttribute>(v8::ReadOnly)); 
	instance->Set(String::NewSymbol("height"), Local<Number>::New(Number::New(this->h)), 
			static_cast<v8::PropertyAttribute>(v8::ReadOnly)); 
	instance->Set(String::NewSymbol("index"), Local<Number>::New(Number::New(this->index)), 
			static_cast<v8::PropertyAttribute>(v8::ReadOnly)); 
	instance->Set(String::NewSymbol("label"), Local<String>::New(String::New(this->label)), 
			static_cast<v8::PropertyAttribute>(v8::ReadOnly)); 
	this->Wrap(Persistent<Object>::New(instance));
}

Handle<Value> Page::GetLinks(Local<String> property, const AccessorInfo &info) {
	HandleScope scope;
	Page* self = ObjectWrap::Unwrap<Page>(info.This());

	if(!self->links.IsEmpty())
		return scope.Close(self->links);

	GList *glinks = poppler_page_get_link_mapping(self->pg), *p;
	int length = g_list_length(glinks), i;
	Local<Array> links = Array::New(length);

	for (i = 0, p = glinks; p; p = p->next, i++) {
		Link *link = new Link(self, (PopplerLinkMapping *) p->data);
		links->Set(i, link->handle_);
	}

	poppler_page_free_link_mapping(glinks);

	self->links = Persistent<Array>::New(links);

	return scope.Close(self->links);
}

Handle<Value> Page::GetText(Local<String> property, const AccessorInfo &info) {
	HandleScope scope;
	Page *self = ObjectWrap::Unwrap<Page>(info.This());

	char *ctext = poppler_page_get_text(self->pg);

	Local<String> text = String::New(ctext);

	return scope.Close(text);
}


Handle<Value> Page::GetTextLayout(Local<String> property, const AccessorInfo &info) {
	HandleScope scope;
	Page* self = ObjectWrap::Unwrap<Page>(info.This());

	PopplerRectangle *grects;
	guint i, length;
	gboolean containsText = poppler_page_get_text_layout(self->pg, &grects, &length);

	if (!containsText) {
		return scope.Close(Array::New(0));
	}

	Local<Array> rects = Array::New(length);

	for (i = 0; i < length; i++) {
		PopplerRectangle *grect = &grects[i];
		Local<Object> rect = Object::New();
		rect->Set(String::NewSymbol("x1"), Local<Number>::New(Number::New(grect->x1)));
		rect->Set(String::NewSymbol("y1"), Local<Number>::New(Number::New(grect->y1)));
		rect->Set(String::NewSymbol("x2"), Local<Number>::New(Number::New(grect->x2)));
		rect->Set(String::NewSymbol("y2"), Local<Number>::New(Number::New(grect->y2)));
		rects->Set(i, rect);
	}

	return scope.Close(rects);
}

Handle<Value> Page::GetTextChunks(Local<String> property, const AccessorInfo &info) {
	HandleScope scope;
	Page* self = ObjectWrap::Unwrap<Page>(info.This());

	PopplerRectangle *grects;
        guint layoutLength;
	gboolean hasText = poppler_page_get_text_layout(self->pg, &grects, &layoutLength);

        GList *gattrs = poppler_page_get_text_attributes(self->pg), *p;
	int length = g_list_length(gattrs), i, j;

	Local<Array> chunks = Array::New(length);
	Local<Object> o;

	for (i = 0, p = gattrs; p; p = p->next, i++) {

                o = Object::New();
		
		PopplerTextAttributes *gattr = (PopplerTextAttributes *)p->data;

		o->Set(String::NewSymbol("fontName"), Local<String>::New(String::New(gattr->font_name)));
		o->Set(String::NewSymbol("fontSize"), Local<Number>::New(Number::New(gattr->font_size)));
		o->Set(String::NewSymbol("isUnderlined"), Local<Boolean>::New(Boolean::New(gattr->is_underlined)));
		o->Set(String::NewSymbol("startIndex"), Local<Integer>::New(Integer::New(gattr->start_index)));
		o->Set(String::NewSymbol("endIndex"), Local<Integer>::New(Integer::New(gattr->end_index)));

		gdouble x1 = 0, y1 = 0, x2 = 0, y2 = 0;
		for (j = gattr->start_index; j <= gattr->end_index; j++) {
			PopplerRectangle *grect = &grects[j];
			if (j == gattr->start_index) {
				x1 = grect->x1;
				y1 = grect->y1;
				x2 = grect->x2;
				y2 = grect->y2;
			} else {
				x1 = min(x1, grect->x1);
				y1 = min(y1, grect->y1);
				x2 = max(x2, grect->x2);
				y2 = max(y2, grect->y2);
			}
		}

		o->Set(String::NewSymbol("x1"), Local<Number>::New(Number::New(x1)));
		o->Set(String::NewSymbol("y1"), Local<Number>::New(Number::New(y1)));
		o->Set(String::NewSymbol("x2"), Local<Number>::New(Number::New(x2)));
		o->Set(String::NewSymbol("y2"), Local<Number>::New(Number::New(y2)));
	
		chunks->Set(i, o);

	}

	poppler_page_free_text_attributes(gattrs);

	g_free(grects);

	return scope.Close(chunks);
}

Handle<Value> Page::GetTextAttributes(Local<String> property, const AccessorInfo &info) {
	HandleScope scope;
	Page* self = ObjectWrap::Unwrap<Page>(info.This());

	GList *gattrs = poppler_page_get_text_attributes(self->pg), *p;
	int length = g_list_length(gattrs), i;
	Local<Array> attrs = Array::New(length);
	Local<Object> attr;

	for (i = 0, p = gattrs; p; p = p->next, i++) {
		PopplerTextAttributes *gattr = (PopplerTextAttributes *)p->data;
                attr = Object::New();
		attr->Set(String::NewSymbol("fontName"), Local<String>::New(String::New(gattr->font_name)));
		attr->Set(String::NewSymbol("fontSize"), Local<Number>::New(Number::New(gattr->font_size)));
		attr->Set(String::NewSymbol("isUnderlined"), Local<Boolean>::New(Boolean::New(gattr->is_underlined)));
		attr->Set(String::NewSymbol("startIndex"), Local<Integer>::New(Integer::New(gattr->start_index)));
		attr->Set(String::NewSymbol("endIndex"), Local<Integer>::New(Integer::New(gattr->end_index)));
		attrs->Set(i, attr);
	}

	poppler_page_free_text_attributes(gattrs);

	return scope.Close(attrs);
}

Handle<Value> Page::ConvertTo(const Arguments& args) {
	HandleScope scope;
	Page* self = ObjectWrap::Unwrap<Page>(args.This());
	int i;

	String::AsciiValue callee(args.Callee()->GetName());
	char *name = *callee;
	int len = callee.length();
	Format format = FORMAT_UNKOWN;
	for(i = 0; formatName(i) != NULL && format == FORMAT_UNKOWN; i++) {
		if(strncmp(name, formatName(i), len) == 0)
			format = (Format)i;
	}
	if(format == FORMAT_UNKOWN)
		return ThrowException(Exception::Error(String::New("unkown format to convert to")));

	PageJob *pj = new PageJob(*self, format);
	if(args.Length() >= 1 && !(args[0]->IsUndefined() || args[0]->IsNull())) {
		if(!args[0]->IsObject())
			return ThrowException(Exception::Error(String::New("first argument must be an Object")));
		pj->calcDimensions(args[0]->ToObject());
	}
	self->document->addJob(pj);

	return pj->handle_;
}
